<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `literal` mod in crate `cexpr`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, literal">

    <title>cexpr::literal - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../normalize.css">
    <link rel="stylesheet" type="text/css" href="../../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../../main.css">
    

    
    
</head>
<body class="rustdoc mod">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        <div class="sidebar-menu">&#9776;</div>
        
        <p class='location'>Module literal</p><div class="sidebar-elems"><div class="block items"><ul><li><a href="#macros">Macros</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></div><p class='location'><a href='../index.html'>cexpr</a></p><script>window.sidebarCurrent = {name: 'literal', ty: 'mod', relpath: '../'};</script><script defer src="../sidebar-items.js"></script></div>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content">
<h1 class='fqn'><span class='in-band'>Module <a href='../index.html'>cexpr</a>::<wbr><a class="mod" href=''>literal</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a class='srclink' href='../../src/cexpr/literal.rs.html#8-267' title='goto source code'>[src]</a></span></h1>
<div class='docblock'><p>Parsing C literals from byte slices.</p>

<p>This will parse a representation of a C literal into a Rust type.</p>

<h1 id='characters' class='section-header'><a href='#characters'>characters</a></h1>
<p>Character literals are stored into the <code>CChar</code> type, which can hold values
that are not valid Unicode code points. ASCII characters are represented as
<code>char</code>, literal bytes with the high byte set are converted into the raw
representation. Escape sequences are supported. If hex and octal escapes
map to an ASCII character, that is used, otherwise, the raw encoding is
used, including for values over 255. Unicode escapes are checked for
validity and mapped to <code>char</code>. Character sequences are not supported. Width
prefixes are ignored.</p>

<h1 id='strings' class='section-header'><a href='#strings'>strings</a></h1>
<p>Strings are interpreted as byte vectors. Escape sequences are supported. If
hex and octal escapes map onto multi-byte characters, they are truncated to
one 8-bit character. Unicode escapes are converted into their UTF-8
encoding. Width prefixes are ignored.</p>

<h1 id='integers' class='section-header'><a href='#integers'>integers</a></h1>
<p>Integers are read into <code>i64</code>. Binary, octal, decimal and hexadecimal are
all supported. If the literal value is between <code>i64::MAX</code> and <code>u64::MAX</code>,
it is bit-cast to <code>i64</code>. Values over <code>u64::MAX</code> cannot be parsed. Width and
sign suffixes are ignored. Sign prefixes are not supported.</p>

<h1 id='real-numbers' class='section-header'><a href='#real-numbers'>real numbers</a></h1>
<p>Reals are read into <code>f64</code>. Width suffixes are ignored. Sign prefixes are
not supported in the significand. Hexadecimal floating points are not
supported.</p>
</div><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.add_return_error.html"
                                  title='macro cexpr::literal::add_return_error'>add_return_error</a></td>
                           <td class='docblock-short'>
                                <p>Add an error if the child parser fails</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.alt.html"
                                  title='macro cexpr::literal::alt'>alt</a></td>
                           <td class='docblock-short'>
                                <p>Try a list of parsers and return the result of the first successful one</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.alt_complete.html"
                                  title='macro cexpr::literal::alt_complete'>alt_complete</a></td>
                           <td class='docblock-short'>
                                <p>Is equivalent to the <code>alt!</code> combinator, except that it will not return <code>Incomplete</code>
when one of the constituting parsers returns <code>Incomplete</code>. Instead, it will try the
next alternative in the chain.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.apply.html"
                                  title='macro cexpr::literal::apply'>apply</a></td>
                           <td class='docblock-short'>
                                <p>emulate function currying: <code>apply!(my_function, arg1, arg2, ...)</code> becomes <code>my_function(input, arg1, arg2, ...)</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.apply_m.html"
                                  title='macro cexpr::literal::apply_m'>apply_m</a></td>
                           <td class='docblock-short'>
                                <p>emulate function currying for method calls on structs
<code>apply_m!(self.my_function, arg1, arg2, ...)</code> becomes <code>self.my_function(input, arg1, arg2, ...)</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.bits.html"
                                  title='macro cexpr::literal::bits'>bits</a></td>
                           <td class='docblock-short'>
                                <p><code>bits!( parser ) =&gt; ( &amp;[u8], (&amp;[u8], usize) -&gt; IResult&lt;(&amp;[u8], usize), T&gt; ) -&gt; IResult&lt;&amp;[u8], T&gt;</code>
transforms its byte slice input into a bit stream for the underlying parsers</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.bytes.html"
                                  title='macro cexpr::literal::bytes'>bytes</a></td>
                           <td class='docblock-short'>
                                <p>Counterpart to bits,
<code>bytes!( parser ) =&gt; ( (&amp;[u8], usize), &amp;[u8] -&gt; IResult&lt;&amp;[u8], T&gt; ) -&gt; IResult&lt;(&amp;[u8], usize), T&gt;</code>,
transforms its bits stream input into a byte slice for the underlying parsers. If we start in the
middle of a byte throws away the bits until the end of the byte.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.call.html"
                                  title='macro cexpr::literal::call'>call</a></td>
                           <td class='docblock-short'>
                                <p>Used to wrap common expressions and function as macros</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.call_m.html"
                                  title='macro cexpr::literal::call_m'>call_m</a></td>
                           <td class='docblock-short'>
                                <p>Used to called methods then move self back into self</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.char.html"
                                  title='macro cexpr::literal::char'>char</a></td>
                           <td class='docblock-short'>
                                <p>matches one character: `char!(char) =&gt; &amp;[u8] -&gt; IResult&lt;&amp;[u8], char&gt;</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.closure.html"
                                  title='macro cexpr::literal::closure'>closure</a></td>
                           <td class='docblock-short'>
                                <p>Wraps a parser in a closure</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.compiler_error.html"
                                  title='macro cexpr::literal::compiler_error'>compiler_error</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.complete.html"
                                  title='macro cexpr::literal::complete'>complete</a></td>
                           <td class='docblock-short'>
                                <p>replaces a <code>Incomplete</code> returned by the child parser
with an <code>Error</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.cond.html"
                                  title='macro cexpr::literal::cond'>cond</a></td>
                           <td class='docblock-short'>
                                <p><code>cond!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;</code>
Conditional combinator</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.cond_reduce.html"
                                  title='macro cexpr::literal::cond_reduce'>cond_reduce</a></td>
                           <td class='docblock-short'>
                                <p><code>cond_reduce!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
Conditional combinator with error</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.cond_with_error.html"
                                  title='macro cexpr::literal::cond_with_error'>cond_with_error</a></td>
                           <td class='docblock-short'>
                                <p><code>cond_with_error!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;</code>
Conditional combinator</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.consumer_from_parser.html"
                                  title='macro cexpr::literal::consumer_from_parser'>consumer_from_parser</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.count.html"
                                  title='macro cexpr::literal::count'>count</a></td>
                           <td class='docblock-short'>
                                <p><code>count!(I -&gt; IResult&lt;I,O&gt;, nb) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the child parser a specified number of times</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.count_fixed.html"
                                  title='macro cexpr::literal::count_fixed'>count_fixed</a></td>
                           <td class='docblock-short'>
                                <p><code>count_fixed!(O, I -&gt; IResult&lt;I,O&gt;, nb) =&gt; I -&gt; IResult&lt;I, [O; nb]&gt;</code>
Applies the child parser a fixed number of times and returns a fixed size array
The type must be specified and it must be <code>Copy</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.dbg.html"
                                  title='macro cexpr::literal::dbg'>dbg</a></td>
                           <td class='docblock-short'>
                                <p>Prints a message if the parser fails</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.dbg_dmp.html"
                                  title='macro cexpr::literal::dbg_dmp'>dbg_dmp</a></td>
                           <td class='docblock-short'>
                                <p>Prints a message and the input if the parser fails</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.delimited.html"
                                  title='macro cexpr::literal::delimited'>delimited</a></td>
                           <td class='docblock-short'>
                                <p><code>delimited!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,U&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
delimited(opening, X, closing) returns X</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.do_parse.html"
                                  title='macro cexpr::literal::do_parse'>do_parse</a></td>
                           <td class='docblock-short'>
                                <p><code>do_parse!(I-&gt;IResult&lt;I,A&gt; &gt;&gt; I-&gt;IResult&lt;I,B&gt; &gt;&gt; ... I-&gt;IResult&lt;I,X&gt; , ( O ) ) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
do_parse applies sub parsers in a sequence.
it can store intermediary results and make them available
for later parsers</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.eat_separator.html"
                                  title='macro cexpr::literal::eat_separator'>eat_separator</a></td>
                           <td class='docblock-short'>
                                <p>helper macros to build a separator parser</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.eof.html"
                                  title='macro cexpr::literal::eof'>eof</a></td>
                           <td class='docblock-short'>
                                <p><code>eof!()</code> returns its input if it is at the end of input data</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.error_code.html"
                                  title='macro cexpr::literal::error_code'>error_code</a></td>
                           <td class='docblock-short'>
                                <p>creates a parse error from a <code>nom::ErrorKind</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.error_node.html"
                                  title='macro cexpr::literal::error_node'>error_node</a></td>
                           <td class='docblock-short'>
                                <p>creates a parse error from a <code>nom::ErrorKind</code>
and the next error in the parsing tree.
if &quot;verbose-errors&quot; is not activated,
it default to only the error code</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.error_node_position.html"
                                  title='macro cexpr::literal::error_node_position'>error_node_position</a></td>
                           <td class='docblock-short'>
                                <p>creates a parse error from a <code>nom::ErrorKind</code>,
the position in the input and the next error in
the parsing tree.
if &quot;verbose-errors&quot; is not activated,
it default to only the error code</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.error_position.html"
                                  title='macro cexpr::literal::error_position'>error_position</a></td>
                           <td class='docblock-short'>
                                <p>creates a parse error from a <code>nom::ErrorKind</code>
and the position in the input
if &quot;verbose-errors&quot; is not activated,
it default to only the error code</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.escaped.html"
                                  title='macro cexpr::literal::escaped'>escaped</a></td>
                           <td class='docblock-short'>
                                <p><code>escaped!(&amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;, T, &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
matches a byte string with escaped characters.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.escaped_transform.html"
                                  title='macro cexpr::literal::escaped_transform'>escaped_transform</a></td>
                           <td class='docblock-short'>
                                <p><code>escaped_transform!(&amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;, T, &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], Vec&lt;T&gt;&gt;</code>
matches a byte string with escaped characters.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.expr_opt.html"
                                  title='macro cexpr::literal::expr_opt'>expr_opt</a></td>
                           <td class='docblock-short'>
                                <p><code>expr_opt!(Option&lt;O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
evaluate an expression that returns a Option<T> and returns a IResult::Done(I,T) if Some</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.expr_res.html"
                                  title='macro cexpr::literal::expr_res'>expr_res</a></td>
                           <td class='docblock-short'>
                                <p><code>expr_res!(Result&lt;E,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
evaluate an expression that returns a Result<T,E> and returns a IResult::Done(I,T) if Ok</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.fix_error.html"
                                  title='macro cexpr::literal::fix_error'>fix_error</a></td>
                           <td class='docblock-short'>
                                <p>translate parser result from IResult<I,O,u32> to IResult<I,O,E> with a custom type</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.flat_map.html"
                                  title='macro cexpr::literal::flat_map'>flat_map</a></td>
                           <td class='docblock-short'>
                                <p><code>flat_map!(R -&gt; IResult&lt;R,S&gt;, S -&gt; IResult&lt;S,T&gt;) =&gt; R -&gt; IResult&lt;R, T&gt;</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.fold_many0.html"
                                  title='macro cexpr::literal::fold_many0'>fold_many0</a></td>
                           <td class='docblock-short'>
                                <p><code>fold_many0!(I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;</code>
Applies the parser 0 or more times and folds the list of return values</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.fold_many1.html"
                                  title='macro cexpr::literal::fold_many1'>fold_many1</a></td>
                           <td class='docblock-short'>
                                <p><code>fold_many1!(I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;</code>
Applies the parser 1 or more times and folds the list of return values</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.fold_many_m_n.html"
                                  title='macro cexpr::literal::fold_many_m_n'>fold_many_m_n</a></td>
                           <td class='docblock-short'>
                                <p><code>fold_many_m_n!(usize, usize, I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;</code>
Applies the parser between m and n times (n included) and folds the list of return value</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.i16.html"
                                  title='macro cexpr::literal::i16'>i16</a></td>
                           <td class='docblock-short'>
                                <p>if the parameter is nom::Endianness::Big, parse a big endian i16 integer,
otherwise a little endian i16 integer</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.i32.html"
                                  title='macro cexpr::literal::i32'>i32</a></td>
                           <td class='docblock-short'>
                                <p>if the parameter is nom::Endianness::Big, parse a big endian i32 integer,
otherwise a little endian i32 integer</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.i64.html"
                                  title='macro cexpr::literal::i64'>i64</a></td>
                           <td class='docblock-short'>
                                <p>if the parameter is nom::Endianness::Big, parse a big endian i64 integer,
otherwise a little endian i64 integer</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.is_a.html"
                                  title='macro cexpr::literal::is_a'>is_a</a></td>
                           <td class='docblock-short'>
                                <p><code>is_a!(&amp;[T]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes that appear in the provided array</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.is_a_s.html"
                                  title='macro cexpr::literal::is_a_s'>is_a_s</a></td>
                           <td class='docblock-short'>
                                <p><code>is_a_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters that appear in the provided array</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.is_not.html"
                                  title='macro cexpr::literal::is_not'>is_not</a></td>
                           <td class='docblock-short'>
                                <p><code>is_not!(&amp;[T:AsBytes]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes that do not appear in the provided array</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.is_not_s.html"
                                  title='macro cexpr::literal::is_not_s'>is_not_s</a></td>
                           <td class='docblock-short'>
                                <p><code>is_not_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters that do not appear in the provided array</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.length_bytes.html"
                                  title='macro cexpr::literal::length_bytes'>length_bytes</a></td>
                           <td class='docblock-short'>
                                <p><code>length_bytes!(&amp;[T] -&gt; IResult&lt;&amp;[T], nb&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
Gets a number from the first parser, then extracts that many bytes from the
remaining stream</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.length_count.html"
                                  title='macro cexpr::literal::length_count'>length_count</a></td>
                           <td class='docblock-short'>
                                <p><code>length_count!(I -&gt; IResult&lt;I, nb&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
gets a number from the first parser, then applies the second parser that many times</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.length_data.html"
                                  title='macro cexpr::literal::length_data'>length_data</a></td>
                           <td class='docblock-short'>
                                <p><code>length_data!(I -&gt; IResult&lt;I, nb&gt;) =&gt; O</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.length_value.html"
                                  title='macro cexpr::literal::length_value'>length_value</a></td>
                           <td class='docblock-short'>
                                <p><code>length_value!(I -&gt; IResult&lt;I, nb&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
gets a number from the first parser, takes a subslice of the input of that size,
then applies the second parser on that subslice. If the second parser returns
<code>Incomplete</code>, <code>length_value</code> will return an error</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.many0.html"
                                  title='macro cexpr::literal::many0'>many0</a></td>
                           <td class='docblock-short'>
                                <p><code>many0!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the parser 0 or more times and returns the list of results in a Vec</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.many1.html"
                                  title='macro cexpr::literal::many1'>many1</a></td>
                           <td class='docblock-short'>
                                <p><code>many1!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the parser 1 or more times and returns the list of results in a Vec</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.many_m_n.html"
                                  title='macro cexpr::literal::many_m_n'>many_m_n</a></td>
                           <td class='docblock-short'>
                                <p><code>many_m_n!(usize, usize, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the parser between m and n times (n included) and returns the list of
results in a Vec</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.many_till.html"
                                  title='macro cexpr::literal::many_till'>many_till</a></td>
                           <td class='docblock-short'>
                                <p><code>many_till!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (Vec&lt;O&gt;, P)&gt;</code>
Applies the first parser until the second applies. Returns a tuple containing the list
of results from the first in a Vec and the result of the second.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.map.html"
                                  title='macro cexpr::literal::map'>map</a></td>
                           <td class='docblock-short'>
                                <p><code>map!(I -&gt; IResult&lt;I,O&gt;, O -&gt; P) =&gt; I -&gt; IResult&lt;I, P&gt;</code>
maps a function on the result of a parser</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.map_opt.html"
                                  title='macro cexpr::literal::map_opt'>map_opt</a></td>
                           <td class='docblock-short'>
                                <p><code>map_opt!(I -&gt; IResult&lt;I,O&gt;, O -&gt; Option&lt;P&gt;) =&gt; I -&gt; IResult&lt;I, P&gt;</code>
maps a function returning an Option on the output of a parser</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.map_res.html"
                                  title='macro cexpr::literal::map_res'>map_res</a></td>
                           <td class='docblock-short'>
                                <p><code>map_res!(I -&gt; IResult&lt;I,O&gt;, O -&gt; Result&lt;P&gt;) =&gt; I -&gt; IResult&lt;I, P&gt;</code>
maps a function returning a Result on the output of a parser</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.method.html"
                                  title='macro cexpr::literal::method'>method</a></td>
                           <td class='docblock-short'>
                                <p>Makes a method from a parser combination</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.named.html"
                                  title='macro cexpr::literal::named'>named</a></td>
                           <td class='docblock-short'>
                                <p>Makes a function from a parser combination</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.named_args.html"
                                  title='macro cexpr::literal::named_args'>named_args</a></td>
                           <td class='docblock-short'>
                                <p>Makes a function from a parser combination with arguments.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.named_attr.html"
                                  title='macro cexpr::literal::named_attr'>named_attr</a></td>
                           <td class='docblock-short'>
                                <p>Makes a function from a parser combination, with attributes</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.none_of.html"
                                  title='macro cexpr::literal::none_of'>none_of</a></td>
                           <td class='docblock-short'>
                                <p>matches anything but the provided characters</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.not.html"
                                  title='macro cexpr::literal::not'>not</a></td>
                           <td class='docblock-short'>
                                <p><code>not!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
returns a result only if the embedded parser returns Error or Incomplete
does not consume the input</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.one_of.html"
                                  title='macro cexpr::literal::one_of'>one_of</a></td>
                           <td class='docblock-short'>
                                <p>matches one of the provided characters</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.opt.html"
                                  title='macro cexpr::literal::opt'>opt</a></td>
                           <td class='docblock-short'>
                                <p><code>opt!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;</code>
make the underlying parser optional</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.opt_res.html"
                                  title='macro cexpr::literal::opt_res'>opt_res</a></td>
                           <td class='docblock-short'>
                                <p><code>opt_res!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Result&lt;nom::Err,O&gt;&gt;</code>
make the underlying parser optional</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.pair.html"
                                  title='macro cexpr::literal::pair'>pair</a></td>
                           <td class='docblock-short'>
                                <p><code>pair!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (O,P)&gt;</code>
pair(X,Y), returns (x,y)</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.parse_to.html"
                                  title='macro cexpr::literal::parse_to'>parse_to</a></td>
                           <td class='docblock-short'>
                                <p><code>parse_to!(O) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
uses the <code>parse</code> method from <code>std::str::FromStr</code> to convert the current
input to the specified type</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.peek.html"
                                  title='macro cexpr::literal::peek'>peek</a></td>
                           <td class='docblock-short'>
                                <p><code>peek!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
returns a result without consuming the input</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.permutation.html"
                                  title='macro cexpr::literal::permutation'>permutation</a></td>
                           <td class='docblock-short'>
                                <p><code>permutation!(I -&gt; IResult&lt;I,A&gt;, I -&gt; IResult&lt;I,B&gt;, ... I -&gt; IResult&lt;I,X&gt; ) =&gt; I -&gt; IResult&lt;I, (A,B,...X)&gt;</code>
applies its sub parsers in a sequence, but independent from their order
this parser will only succeed if all of its sub parsers succeed</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.preceded.html"
                                  title='macro cexpr::literal::preceded'>preceded</a></td>
                           <td class='docblock-short'>
                                <p><code>preceded!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
preceded(opening, X) returns X</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.recognize.html"
                                  title='macro cexpr::literal::recognize'>recognize</a></td>
                           <td class='docblock-short'>
                                <p><code>recognize!(I -&gt; IResult&lt;I, O&gt; ) =&gt; I -&gt; IResult&lt;I, I&gt;</code>
if the child parser was successful, return the consumed input as produced value</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.return_error.html"
                                  title='macro cexpr::literal::return_error'>return_error</a></td>
                           <td class='docblock-short'>
                                <p>Prevents backtracking if the child parser fails</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.sep.html"
                                  title='macro cexpr::literal::sep'>sep</a></td>
                           <td class='docblock-short'>
                                <p>sep is the parser rewriting macro for whitespace separated formats</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.separated_list.html"
                                  title='macro cexpr::literal::separated_list'>separated_list</a></td>
                           <td class='docblock-short'>
                                <p><code>separated_list!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
separated_list(sep, X) returns Vec<X> will return Incomplete if there may be more elements</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.separated_list_complete.html"
                                  title='macro cexpr::literal::separated_list_complete'>separated_list_complete</a></td>
                           <td class='docblock-short'>
                                <p><code>separated_list_complete!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
This is equivalent to the <code>separated_list!</code> combinator, except that it will return <code>Error</code>
when either the separator or element subparser returns <code>Incomplete</code>.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.separated_nonempty_list.html"
                                  title='macro cexpr::literal::separated_nonempty_list'>separated_nonempty_list</a></td>
                           <td class='docblock-short'>
                                <p><code>separated_nonempty_list!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
separated_nonempty_list(sep, X) returns Vec<X> will return Incomplete if there may be more elements</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.separated_nonempty_list_complete.html"
                                  title='macro cexpr::literal::separated_nonempty_list_complete'>separated_nonempty_list_complete</a></td>
                           <td class='docblock-short'>
                                <p><code>separated_nonempty_list_complete!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
This is equivalent to the <code>separated_nonempty_list!</code> combinator, except that it will return
<code>Error</code> when either the separator or element subparser returns <code>Incomplete</code>.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.separated_pair.html"
                                  title='macro cexpr::literal::separated_pair'>separated_pair</a></td>
                           <td class='docblock-short'>
                                <p><code>separated_pair!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I, T&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (O,P)&gt;</code>
separated_pair(X,sep,Y) returns (x,y)</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.switch.html"
                                  title='macro cexpr::literal::switch'>switch</a></td>
                           <td class='docblock-short'>
                                <p><code>switch!(I -&gt; IResult&lt;I,P&gt;, P =&gt; I -&gt; IResult&lt;I,O&gt; | ... | P =&gt; I -&gt; IResult&lt;I,O&gt; ) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
choose the next parser depending on the result of the first one, if successful,
and returns the result of the second parser</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.tag.html"
                                  title='macro cexpr::literal::tag'>tag</a></td>
                           <td class='docblock-short'>
                                <p><code>tag!(&amp;[T]: nom::AsBytes) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
declares a byte array as a suite to recognize</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.tag_bits.html"
                                  title='macro cexpr::literal::tag_bits'>tag_bits</a></td>
                           <td class='docblock-short'>
                                <p>matches an integer pattern to a bitstream. The number of bits of the input to compare must be specified</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.tag_no_case.html"
                                  title='macro cexpr::literal::tag_no_case'>tag_no_case</a></td>
                           <td class='docblock-short'>
                                <p><code>tag_no_case!(&amp;[T]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
declares a case insensitive ascii string as a suite to recognize</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.tag_no_case_s.html"
                                  title='macro cexpr::literal::tag_no_case_s'>tag_no_case_s</a></td>
                           <td class='docblock-short'>
                                <p><code>tag_no_case_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
declares a case-insensitive string as a suite to recognize</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.tag_s.html"
                                  title='macro cexpr::literal::tag_s'>tag_s</a></td>
                           <td class='docblock-short'>
                                <p><code>tag_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
declares a string as a suite to recognize</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take.html"
                                  title='macro cexpr::literal::take'>take</a></td>
                           <td class='docblock-short'>
                                <p><code>take!(nb) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
generates a parser consuming the specified number of bytes</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_bits.html"
                                  title='macro cexpr::literal::take_bits'>take_bits</a></td>
                           <td class='docblock-short'>
                                <p><code>take_bits!(type, nb) =&gt; ( (&amp;[T], usize), U, usize) -&gt; IResult&lt;(&amp;[T], usize), U&gt;</code>
generates a parser consuming the specified number of bits.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_s.html"
                                  title='macro cexpr::literal::take_s'>take_s</a></td>
                           <td class='docblock-short'>
                                <p><code>take_s!(nb) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
generates a parser consuming the specified number of characters</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_str.html"
                                  title='macro cexpr::literal::take_str'>take_str</a></td>
                           <td class='docblock-short'>
                                <p><code>take_str!(nb) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;str&gt;</code>
same as take! but returning a &amp;str</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_till.html"
                                  title='macro cexpr::literal::take_till'>take_till</a></td>
                           <td class='docblock-short'>
                                <p><code>take_till!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes until the provided function succeeds</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_till1.html"
                                  title='macro cexpr::literal::take_till1'>take_till1</a></td>
                           <td class='docblock-short'>
                                <p><code>take_till1!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest non empty list of bytes until the provided function succeeds</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_till1_s.html"
                                  title='macro cexpr::literal::take_till1_s'>take_till1_s</a></td>
                           <td class='docblock-short'>
                                <p><code>take_till1_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest non empty list of characters until the provided function succeeds</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_till_s.html"
                                  title='macro cexpr::literal::take_till_s'>take_till_s</a></td>
                           <td class='docblock-short'>
                                <p><code>take_till_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters until the provided function succeeds</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until.html"
                                  title='macro cexpr::literal::take_until'>take_until</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data until it finds the specified tag</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until1.html"
                                  title='macro cexpr::literal::take_until1'>take_until1</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until1!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data until it finds the specified tag</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until_and_consume.html"
                                  title='macro cexpr::literal::take_until_and_consume'>take_until_and_consume</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until_and_consume!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
generates a parser consuming bytes until the specified byte sequence is found, and consumes it</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until_and_consume1.html"
                                  title='macro cexpr::literal::take_until_and_consume1'>take_until_and_consume1</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until_and_consume1!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
generates a parser consuming bytes (at least 1) until the specified byte sequence is found, and consumes it</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until_and_consume_s.html"
                                  title='macro cexpr::literal::take_until_and_consume_s'>take_until_and_consume_s</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until_and_consume_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
generates a parser consuming all chars until the specified string is found and consumes it</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until_either.html"
                                  title='macro cexpr::literal::take_until_either'>take_until_either</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until_either!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until_either_and_consume.html"
                                  title='macro cexpr::literal::take_until_either_and_consume'>take_until_either_and_consume</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until_either_and_consume!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data until it finds any of the specified characters, and consume it</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until_s.html"
                                  title='macro cexpr::literal::take_until_s'>take_until_s</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
generates a parser consuming all chars until the specified string is found and leaves it in the remaining input</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_while.html"
                                  title='macro cexpr::literal::take_while'>take_while</a></td>
                           <td class='docblock-short'>
                                <p><code>take_while!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes until the provided function fails.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_while1.html"
                                  title='macro cexpr::literal::take_while1'>take_while1</a></td>
                           <td class='docblock-short'>
                                <p><code>take_while1!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest (non empty) list of bytes until the provided function fails.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_while1_s.html"
                                  title='macro cexpr::literal::take_while1_s'>take_while1_s</a></td>
                           <td class='docblock-short'>
                                <p><code>take_while1_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest (non empty) list of characters until the provided function fails.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_while_s.html"
                                  title='macro cexpr::literal::take_while_s'>take_while_s</a></td>
                           <td class='docblock-short'>
                                <p><code>take_while_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters until the provided function fails.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.tap.html"
                                  title='macro cexpr::literal::tap'>tap</a></td>
                           <td class='docblock-short'>
                                <p><code>tap!(name: I -&gt; IResult&lt;I,O&gt; =&gt; { block }) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
allows access to the parser&#39;s result without affecting it</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.terminated.html"
                                  title='macro cexpr::literal::terminated'>terminated</a></td>
                           <td class='docblock-short'>
                                <p><code>terminated!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,T&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
terminated(X, closing) returns X</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.try_parse.html"
                                  title='macro cexpr::literal::try_parse'>try_parse</a></td>
                           <td class='docblock-short'>
                                <p>A bit like <code>std::try!</code>, this macro will return the remaining input and parsed value if the child parser returned <code>Done</code>,
and will do an early return for <code>Error</code> and <code>Incomplete</code>
this can provide more flexibility than <code>do_parse!</code> if needed</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.tuple.html"
                                  title='macro cexpr::literal::tuple'>tuple</a></td>
                           <td class='docblock-short'>
                                <p><code>tuple!(I-&gt;IResult&lt;I,A&gt;, I-&gt;IResult&lt;I,B&gt;, ... I-&gt;IResult&lt;I,X&gt;) =&gt; I -&gt; IResult&lt;I, (A, B, ..., X)&gt;</code>
chains parsers and assemble the sub results in a tuple.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.u16.html"
                                  title='macro cexpr::literal::u16'>u16</a></td>
                           <td class='docblock-short'>
                                <p>if the parameter is nom::Endianness::Big, parse a big endian u16 integer,
otherwise a little endian u16 integer</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.u32.html"
                                  title='macro cexpr::literal::u32'>u32</a></td>
                           <td class='docblock-short'>
                                <p>if the parameter is nom::Endianness::Big, parse a big endian u32 integer,
otherwise a little endian u32 integer</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.u64.html"
                                  title='macro cexpr::literal::u64'>u64</a></td>
                           <td class='docblock-short'>
                                <p>if the parameter is nom::Endianness::Big, parse a big endian u64 integer,
otherwise a little endian u64 integer</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.value.html"
                                  title='macro cexpr::literal::value'>value</a></td>
                           <td class='docblock-short'>
                                <p><code>value!(T, R -&gt; IResult&lt;R, S&gt; ) =&gt; R -&gt; IResult&lt;R, T&gt;</code></p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.verify.html"
                                  title='macro cexpr::literal::verify'>verify</a></td>
                           <td class='docblock-short'>
                                <p><code>verify!(I -&gt; IResult&lt;I,O&gt;, O -&gt; bool) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
returns the result of the child parser if it satisfies a verification function</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.wrap_sep.html"
                                  title='macro cexpr::literal::wrap_sep'>wrap_sep</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.ws.html"
                                  title='macro cexpr::literal::ws'>ws</a></td>
                           <td class='docblock-short'>
                                <p><code>ws!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code></p>
                           </td>
                       </tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.CChar.html"
                                  title='enum cexpr::literal::CChar'>CChar</a></td>
                           <td class='docblock-short'>
                                <p>Representation of a C character</p>
                           </td>
                       </tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.parse.html"
                                  title='fn cexpr::literal::parse'>parse</a></td>
                           <td class='docblock-short'>
                                <p>Parse a C literal.</p>
                           </td>
                       </tr></table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>↑</dt>
                    <dd>Move up in search results</dd>
                    <dt>↓</dt>
                    <dd>Move down in search results</dd>
                    <dt>↹</dt>
                    <dd>Switch tab</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt style="width:31px;">+ / -</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "cexpr";
    </script>
    <script src="../../main.js"></script>
    <script defer src="../../search-index.js"></script>
</body>
</html>